import { gameState } from "../../state/stateManagers.js";
import { colorizeBackground, audioManager } from "../../utils.js";
import { createTutorialDialog } from "../tutorialDialog.js";

export default function tutorial(k) {
    console.log("üéì Tutorial Ïî¨ ÏãúÏûë");
    
    // Í∏∞Ï°¥ BGM Ï†ïÏßÄ Î∞è ÏÉà BGM Ïû¨ÏÉù
    audioManager.stopBGM();
    audioManager.playBGM("rpg-main-bgm");
    
    // Í≤ÄÏùÄÏÉâ Î∞∞Í≤Ω
    colorizeBackground(k, 0, 0, 0);
    
    // Î¨∏ÏÑú Î∞∞Í≤ΩÎèÑ Í≤ÄÏùÄÏÉâÏúºÎ°ú ÏÑ§Ï†ï
    document.body.style.backgroundColor = 'black';
    
    // JavaScriptÎ°ú ÌéòÏù¥Îìú Ïù∏ Ìö®Í≥º
    const fadeInOverlay = document.createElement('div');
    fadeInOverlay.style.position = 'fixed';
    fadeInOverlay.style.top = '0';
    fadeInOverlay.style.left = '0';
    fadeInOverlay.style.width = '100vw';
    fadeInOverlay.style.height = '100vh';
    fadeInOverlay.style.backgroundColor = 'black';
    fadeInOverlay.style.opacity = '1';
    fadeInOverlay.style.zIndex = '10000';
    fadeInOverlay.style.pointerEvents = 'none';
    fadeInOverlay.style.transition = 'opacity 2s ease-out';
    document.body.appendChild(fadeInOverlay);
    
    console.log("üåÖ Tutorial ÌéòÏù¥Îìú Ïù∏ ÏãúÏûë");
    
    // ÌéòÏù¥Îìú Ïù∏ ÏãúÏûë
    setTimeout(() => {
        fadeInOverlay.style.opacity = '0';
        console.log("üåÖ Tutorial ÌéòÏù¥Îìú ÏßÑÌñâ: ÏãúÏûë");
    }, 50);
    
    // ÌéòÏù¥Îìú Ïù∏ ÏôÑÎ£å ÌõÑ Ïò§Î≤ÑÎ†àÏù¥ Ï†úÍ±∞
    setTimeout(() => {
        console.log("‚ú® Tutorial Fade In ÏôÑÎ£å");
        if (fadeInOverlay && fadeInOverlay.parentNode) {
            document.body.removeChild(fadeInOverlay);
        }
    }, 2100);

    // Ìå®ÌÑ¥ Î∞∞Í≤Ω Ï∂îÍ∞Ä
    const patterns = [];
    const patternSize = 1280;
    const screenWidth = k.width();
    const screenHeight = k.height();
    const extraPadding = patternSize;
    
    for (let x = -extraPadding; x <= screenWidth + extraPadding; x += patternSize) {
        for (let y = -extraPadding; y <= screenHeight + extraPadding; y += patternSize) {
            const pattern = k.add([
                k.sprite("pattern_lightgreen"),
                k.pos(x, y),
                k.z(0),
                k.fixed(),
            ]);
            patterns.push(pattern);
        }
    }

    // Ìå®ÌÑ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
    const patternSpeed = 30;
    k.onUpdate(() => {
        patterns.forEach(pattern => {
            pattern.pos.x -= patternSpeed * k.dt();
            pattern.pos.y += patternSpeed * k.dt();
            
            if (pattern.pos.x <= -patternSize) {
                pattern.pos.x += patternSize * Math.ceil((screenWidth + extraPadding * 2) / patternSize);
            }
            if (pattern.pos.y >= screenHeight + patternSize) {
                pattern.pos.y -= patternSize * Math.ceil((screenHeight + extraPadding * 2) / patternSize);
            }
        });
    });

    // TUTORIAL ÌÉÄÏù¥ÌãÄ
    const titleText = k.add([
        k.text("TUTORIAL", { 
            size: 38,
            font: "gameboy"
        }),
        k.anchor("center"),
        k.pos(k.center().x, 120),
        k.color(105, 215, 23),
        k.z(10),
        k.fixed(),
    ]);

    // Ï¥àÍ∏∞ ÌÖçÏä§Ìä∏
    const centerText = k.add([
        k.text("Ìäú ÌÜ† Î¶¨ Ïñº ÏùÑ  Ïãú Ïûë Ìï© Îãà Îã§ .", { 
            size: 26,
            font: "galmuri"
        }),
        k.anchor("center"),
        k.pos(k.center().x, k.center().y),
        k.color(111, 111, 111),
        k.opacity(0),
        k.z(10),
        k.fixed(),
    ]);

    // Í≤åÏûÑ Ïò§Î∏åÏ†ùÌä∏ Î≥ÄÏàòÎì§
    let player = null;
    let npc = null;
    let isNearNPC = false;
    let exclamationMark = null;
    let tutorialText = null;
    let tutorialStep = 0;
    let hasPlayerMoved = false;
    let documentKeyHandler = null;
    
    // Ïù¥Îèô Í¥ÄÎ†® Î≥ÄÏàò
    const MOVE_SPEED = 120;
    const CENTER_X = k.center().x;
    const CENTER_Y = k.center().y;
    const MOVE_RADIUS = 100;
    let currentAnimDirection = "down";
    let isCurrentlyMoving = false;
    let keyStates = {
        left: false,
        right: false,
        up: false,
        down: false
    };
    
    // Ïù¥Îèô Ï∂îÏ†Å Î≥ÄÏàò
    let movementTracking = {
        left: false,
        right: false,
        up: false,
        down: false,
        startTime: null,
        indicators: {},
        directionTimes: {
            left: 0,
            right: 0,
            up: 0,
            down: 0
        },
        requiredTime: 500
    };

    // 1Îã®Í≥Ñ: Ï¥àÍ∏∞ ÌÖçÏä§Ìä∏ ÌëúÏãú
    k.wait(2.5, () => {
        console.log("üéì ÌäúÌÜ†Î¶¨Ïñº Ï¥àÍ∏∞ ÌÖçÏä§Ìä∏ fade in ÏãúÏûë");
        
        k.tween(centerText.opacity, 1, 1, (val) => {
            centerText.opacity = val;
        }).then(() => {
            console.log("üéì Ï¥àÍ∏∞ ÌÖçÏä§Ìä∏ ÌëúÏãú ÏôÑÎ£å");
            
            k.wait(1, () => {
                k.tween(centerText.opacity, 0, 1, (val) => {
                    centerText.opacity = val;
                }).then(() => {
                    console.log("üéì Ï¥àÍ∏∞ ÌÖçÏä§Ìä∏ fade out ÏôÑÎ£å");
                    k.wait(0.5, () => {
                        startCharacterTutorial();
                    });
                });
            });
        });
    });

    function startCharacterTutorial() {
        tutorialStep = 1;
        centerText.opacity = 0;
        
        // ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
        player = k.add([
            k.sprite("main-assets", { anim: "player-idle-down" }),
            k.anchor("center"),
            k.pos(k.center().x, k.center().y),
            k.scale(0.1),
            k.area({ width: 86, height: 86 }),
            k.body(),
            k.opacity(0),
            k.z(20),
            "player"
        ]);
        
        // ÌäúÌÜ†Î¶¨Ïñº ÌÖçÏä§Ìä∏
        tutorialText = k.add([
            k.text("ÌôîÏÇ¥Ìëú ÌÇ§Î•º ÎàåÎü¨ ÏÉÅÌïòÏ¢åÏö∞Î°ú ÏõÄÏßÅÏó¨Î≥¥ÏÑ∏Ïöî.", { 
                size: 20,
                font: "galmuri",
                width: k.width() - 100,
                align: "center"
            }),
            k.anchor("center"),
            k.pos(k.center().x, k.height() - 120),
            k.color(50, 200, 50),
            k.opacity(0),
            k.z(10),
            k.fixed(),
        ]);
        
        createMovementIndicators();
        
        // ÌîåÎ†àÏù¥Ïñ¥ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
        k.tween(player.scale, k.vec2(3.6, 3.6), 1.2, (val) => {
            player.scale = val;
        }, k.easings.easeOutBack);
        
        k.tween(player.opacity, 1, 1.2, (val) => {
            player.opacity = val;
        });
        
        k.wait(0.8, () => {
            k.tween(tutorialText.opacity, 1, 0.8, (val) => {
                tutorialText.opacity = val;
            });
            
            k.wait(0.2, () => {
                showMovementIndicators();
                movementTracking.startTime = Date.now();
            });
        });
    }

    function createMovementIndicators() {
        const baseY = k.height() - 160;
        const centerX = k.center().x;
        const spacing = 60;
        
        const directions = [
            { key: 'left', pos: { x: centerX - spacing * 1.5, y: baseY }, symbol: '‚Üê' },
            { key: 'right', pos: { x: centerX - spacing * 0.5, y: baseY }, symbol: '‚Üí' },
            { key: 'up', pos: { x: centerX + spacing * 0.5, y: baseY }, symbol: '‚Üë' },
            { key: 'down', pos: { x: centerX + spacing * 1.5, y: baseY }, symbol: '‚Üì' }
        ];
        
        directions.forEach(dir => {
            const bgCircle = k.add([
                k.circle(16),
                k.pos(dir.pos.x, dir.pos.y),
                k.anchor("center"),
                k.color(60, 60, 60),
                k.opacity(0),
                k.z(15),
                k.fixed(),
                "movementIndicator"
            ]);
            
            const completeCircle = k.add([
                k.circle(16),
                k.pos(dir.pos.x, dir.pos.y),
                k.anchor("center"),
                k.color(50, 200, 50),
                k.opacity(0),
                k.z(16),
                k.fixed(),
                "movementIndicator"
            ]);
            
            const dirText = k.add([
                k.text(dir.symbol, {
                    size: 20,
                    font: "galmuri"
                }),
                k.pos(dir.pos.x, dir.pos.y),
                k.anchor("center"),
                k.color(255, 255, 255),
                k.opacity(0),
                k.z(17),
                k.fixed(),
                "movementIndicator"
            ]);
            
            movementTracking.indicators[dir.key] = {
                background: bgCircle,
                complete: completeCircle,
                text: dirText,
                completed: false
            };
        });
    }
    
    function showMovementIndicators() {
        Object.values(movementTracking.indicators).forEach(indicator => {
            k.tween(indicator.background.opacity, 0.7, 0.5, (val) => {
                indicator.background.opacity = val;
            });
            k.tween(indicator.text.opacity, 1, 0.5, (val) => {
                indicator.text.opacity = val;
            });
        });
    }
    
    function markDirectionComplete(direction) {
        if (movementTracking.indicators[direction] && !movementTracking.indicators[direction].completed) {
            movementTracking.indicators[direction].completed = true;
            movementTracking[direction] = true;
            
            const indicator = movementTracking.indicators[direction];
            
            k.tween(indicator.complete.opacity, 0.9, 0.5, (val) => {
                indicator.complete.opacity = val;
            });
            
            k.tween(indicator.text.color.r, 0, 0.5, (val) => {
                indicator.text.color = k.rgb(val, val, val);
            });
            
            console.log(`‚úÖ Î∞©Ìñ• ÏôÑÎ£å: ${direction}`);
            checkMovementCompletion();
        }
    }
    
    function updateDirectionTime(direction, deltaTime) {
        if (!movementTracking.indicators[direction].completed) {
            movementTracking.directionTimes[direction] += deltaTime;
            
            if (movementTracking.directionTimes[direction] >= movementTracking.requiredTime) {
                markDirectionComplete(direction);
            }
        }
    }
    
    function checkMovementCompletion() {
        const allDirectionsComplete = movementTracking.left && 
                                    movementTracking.right && 
                                    movementTracking.up && 
                                    movementTracking.down;
        
        if (allDirectionsComplete) {
            console.log("üéâ Î™®Îì† Î∞©Ìñ• Ïù¥Îèô ÏôÑÎ£å!");
            k.destroyAll("movementIndicator");
            
            k.wait(0.3, () => {
                showWellDoneMessage();
            });
        }
    }

    function showWellDoneMessage() {
        tutorialStep = 2;
        k.destroyAll("movementIndicator");
        
        if (player) {
            player.play("player-idle-down");
            currentAnimDirection = "down";
            isCurrentlyMoving = false;
            
            keyStates = {
                left: false,
                right: false,
                up: false,
                down: false
            };
            
            movementTracking = {
                left: false,
                right: false,
                up: false,
                down: false,
                startTime: null,
                indicators: {},
                directionTimes: {
                    left: 0,
                    right: 0,
                    up: 0,
                    down: 0
                },
                requiredTime: 500
            };
        }
        
        k.tween(tutorialText.opacity, 0, 1, (val) => {
            tutorialText.opacity = val;
        }).then(() => {
            const wellDoneText = k.add([
                k.text("ÏûòÌñàÏäµÎãàÎã§!", { 
                    size: 28,
                    font: "galmuri",
                    align: "center"
                }),
                k.anchor("center"),
                k.pos(k.center().x, k.height() - 120),
                k.color(50, 200, 50),
                k.opacity(0),
                k.z(10),
                k.fixed(),
            ]);
            
            k.tween(wellDoneText.opacity, 1, 1, (val) => {
                wellDoneText.opacity = val;
            }).then(() => {
                k.wait(2, () => {
                    k.tween(wellDoneText.opacity, 0, 1, (val) => {
                        wellDoneText.opacity = val;
                    }).then(() => {
                        wellDoneText.destroy();
                        showNPCAndDialogueTutorial();
                    });
                });
            });
        });
    }

    function showNPCAndDialogueTutorial() {
        tutorialStep = 3;
        
        // Ï™ΩÏßÄ ÏÉùÏÑ± (ÏΩúÎùºÏù¥Îçî Ï°∞Ï†ï)
        npc = k.add([
            k.sprite("main-assets", { frame: 5378 }),
            k.anchor("center"),
            k.pos(player.pos.x - 120, player.pos.y),
            k.scale(3.6),
            k.area({ width: 25, height: 25 }), // ÏûëÏùÄ ÏΩúÎùºÏù¥Îçî
            k.body({ isStatic: true }),
            k.opacity(0),
            k.z(20),
            "npc",
            "letter"
        ]);
        
        k.tween(npc.opacity, 1, 1, (val) => {
            npc.opacity = val;
        }).then(() => {
            showDialogueTutorialText();
        });
    }

    function showDialogueTutorialText() {
        tutorialStep = 4;
        
        const dialogueText = k.add([
            k.text("Ï™ΩÏßÄÏôÄ Í∞ôÏùÄ ÏÇ¨Î¨ºÎèÑ ÎòëÍ∞ôÏù¥ Ïä§ÌéòÏù¥Ïä§Î•º ÎàåÎü¨ ÏÉÅÌò∏ÏûëÏö© Ìï† Ïàò ÏûàÏäµÎãàÎã§!", { 
                size: 20,
                font: "galmuri",
                width: k.width() - 100,
                align: "center"
            }),
            k.anchor("center"),
            k.pos(k.center().x, k.height() - 120),
            k.color(50, 200, 50),
            k.opacity(0),
            k.z(10),
            k.fixed(),
            "tutorialText"
        ]);
        
        k.tween(dialogueText.opacity, 1, 1, (val) => {
            dialogueText.opacity = val;
        });
    }

    function handleLetterInteraction() {
        console.log("üèÜ Letter ÏÉÅÌò∏ÏûëÏö© ÏôÑÎ£å!");
        tutorialStep = 5;
        
        k.destroyAll("tutorialText");
        
        const letterComplete = k.add([
            k.text("ÏûòÌñàÏäµÎãàÎã§!", {
                font: "galmuri",
                size: 28,
                align: "center"
            }),
            k.color(50, 200, 50),
            k.pos(k.center().x, k.height() - 120),
            k.anchor("center"),
            k.opacity(0),
            k.z(10),
            k.fixed(),
            "tutorialText"
        ]);
        
        k.tween(letterComplete.opacity, 1, 1, (val) => {
            letterComplete.opacity = val;
        }).then(() => {
            k.wait(2, () => {
                k.tween(letterComplete.opacity, 0, 1, (val) => {
                    letterComplete.opacity = val;
                }).then(() => {
                    letterComplete.destroy();
                    showFriendTutorial();
                });
            });
        });
    }

    function showFriendTutorial() {
        tutorialStep = 6;
        
        if (npc) {
            npc.destroy();
        }
        
        // ÏπúÍµ¨ ÏÉùÏÑ± (ÏΩúÎùºÏù¥Îçî Ï°∞Ï†ï)
        npc = k.add([
            k.sprite("main-assets", { frame: 3781 }),
            k.anchor("center"),
            k.pos(player.pos.x + 120, player.pos.y),
            k.scale(3.6),
            k.area({ width: 30, height: 86 }), // ÏÇ¨Îûå ÌÅ¨Í∏∞ ÏΩúÎùºÏù¥Îçî
            k.body({ isStatic: true }),
            k.opacity(0),
            k.z(20),
            "npc",
            "student1"
        ]);
        
        k.tween(npc.opacity, 1, 1, (val) => {
            npc.opacity = val;
        }).then(() => {
            showFriendTutorialText();
        });
    }

    function showFriendTutorialText() {
        tutorialStep = 7;
        
        const friendText = k.add([
            k.text("ÏπúÍµ¨ÏóêÍ≤å Îã§Í∞ÄÍ∞ÄÏÑú Ïä§ÌéòÏù¥Ïä§Î∞îÎ•º ÎàåÎü¨ ÎßêÏùÑ Í±∞ÏÑ∏Ïöî.", { 
                size: 20,
                font: "galmuri",
                width: k.width() - 100,
                align: "center"
            }),
            k.anchor("center"),
            k.pos(k.center().x, k.height() - 120),
            k.color(50, 200, 50),
            k.opacity(0),
            k.z(10),
            k.fixed(),
            "tutorialText"
        ]);
        
        k.tween(friendText.opacity, 1, 1, (val) => {
            friendText.opacity = val;
        });
    }

    function handleNPCInteraction() {
        if (npc && tutorialStep === 7) {
            // ÎßêÌíçÏÑ† Ïï†ÎãàÎ©îÏù¥ÏÖò
            exclamationMark = k.add([
                k.sprite("main-assets", { frame: 5776 }),
                k.pos(npc.pos.x, npc.pos.y - 60),
                k.anchor("center"),
                k.scale(2),
                k.z(1000),
                "bubble-indicator"
            ]);
            
            k.tween(exclamationMark.scale, k.vec2(2.5, 2.5), 0.3, (val) => {
                exclamationMark.scale = val;
            }, k.easings.easeOutBack);
            
            // ÌùîÎì§Í∏∞ Ìö®Í≥º
            const originalX = exclamationMark.pos.x;
            let shakeCount = 0;
            const shakeInterval = setInterval(() => {
                if (exclamationMark && shakeCount < 6) {
                    const shakeAmount = 3;
                    exclamationMark.pos.x = originalX + (shakeCount % 2 === 0 ? shakeAmount : -shakeAmount);
                    shakeCount++;
                } else {
                    clearInterval(shakeInterval);
                    if (exclamationMark) {
                        exclamationMark.pos.x = originalX;
                    }
                }
            }, 100);
            
            k.wait(1, () => {
                if (exclamationMark) {
                    exclamationMark.destroy();
                    exclamationMark = null;
                }
                startTutorialDialog();
            });
        }
    }

    // ÏôÑÏ†ÑÌïú ÎåÄÌôî ÏãúÏä§ÌÖú
    function startTutorialDialog() {
        console.log("üé≠ ÌäúÌÜ†Î¶¨Ïñº ÎåÄÌôî ÏãúÏûë");
        
        const dialogData = [
            { character: "???", text: "..." },
            { character: "???", text: "......" },
            { character: "???", text: "...ÍπúÏßùÏù¥Ïïº!!!" }
        ];
        
        const shiftDialogData = [
            { character: "???", text: "Î≠êÏïº ÎÑå! Ï≤òÏùåÎ≥¥Îäî ÏñºÍµ¥Ïù∏Îç∞." },
            { character: "???", text: "Ïôú ÎÇ† Î∞©Ìï¥ÌïòÎäîÍ±∞Ïïº?" }
        ];
        
        let currentDialogIndex = 0;
        let isDialogActive = true;
        let dialogBox = null;
        let dialogText = null;
        let nameText = null;
        let helpText = null;
        let helpTextVisible = false;
        let helpTextTimer = null;
        let isShiftTutorial = false;
        
        function createDialogBox() {
            // ÎåÄÌôîÏ∞Ω Î∞∞Í≤Ω
            dialogBox = k.add([
                k.rect(k.width() - 120, 160),
                k.pos(60, k.height() - 200),
                k.color(0, 0, 0),
                k.opacity(0.8),
                k.z(2000),
                k.fixed(),
                "tutorialDialog"
            ]);
            
            // ÌÖåÎëêÎ¶¨
            k.add([
                k.rect(k.width() - 120, 160),
                k.pos(60, k.height() - 200),
                k.outline(3, k.rgb(255, 255, 255)),
                k.z(2001),
                k.fixed(),
                "tutorialDialog"
            ]);
            
            // Ïù¥Î¶Ñ ÌÉ≠
            k.add([
                k.rect(120, 40),
                k.pos(80, k.height() - 220),
                k.color(50, 50, 50),
                k.z(2002),
                k.fixed(),
                "tutorialDialog"
            ]);
            
            k.add([
                k.rect(120, 40),
                k.pos(80, k.height() - 220),
                k.outline(2, k.rgb(255, 255, 255)),
                k.z(2003),
                k.fixed(),
                "tutorialDialog"
            ]);
            
            nameText = k.add([
                k.text("???", {
                    size: 18,
                    font: "galmuri"
                }),
                k.pos(140, k.height() - 200),
                k.anchor("center"),
                k.color(255, 255, 255),
                k.z(2004),
                k.fixed(),
                "tutorialDialog"
            ]);
            
            dialogText = k.add([
                k.text("", {
                    size: 20,
                    font: "galmuri",
                    width: k.width() - 180
                }),
                k.pos(90, k.height() - 170),
                k.color(255, 255, 255),
                k.z(2004),
                k.fixed(),
                "tutorialDialog"
            ]);
            
            showCurrentDialog();
        }
        
        function showCurrentDialog() {
            hideHelpText();
            
            if (!isShiftTutorial && currentDialogIndex < dialogData.length) {
                const dialog = dialogData[currentDialogIndex];
                dialogText.text = dialog.text;
                nameText.text = dialog.character;
                
                helpTextTimer = setTimeout(() => {
                    showHelpText("Ïä§ÌéòÏù¥Ïä§ ÌÇ§Î•º ÎàÑÎ•¥ÏÑ∏Ïöî");
                }, 1000);
                
            } else if (isShiftTutorial && currentDialogIndex < shiftDialogData.length) {
                const dialog = shiftDialogData[currentDialogIndex];
                dialogText.text = dialog.text;
                nameText.text = dialog.character;
                
                if (currentDialogIndex === 0) {
                    helpTextTimer = setTimeout(() => {
                        showHelpText("Shift ÌÇ§Î•º ÎàÑÎ•¥Î©¥ Îπ†Î•¥Í≤å ÎÑòÍ∏∏ Ïàò ÏûàÏäµÎãàÎã§!");
                    }, 100);
                }
            }
        }
        
        function showHelpText(text) {
            if (helpText) {
                helpText.destroy();
                helpText = null;
            }
            
            helpText = k.add([
                k.text(text, {
                    size: 14,
                    font: "galmuri"
                }),
                k.pos(k.center().x, k.height() - 240),
                k.anchor("center"),
                k.color(150, 150, 150),
                k.opacity(0),
                k.z(2005),
                k.fixed(),
                "tutorialDialog"
            ]);
            
            helpTextVisible = true;
            
            const blinkTween = () => {
                if (helpTextVisible && helpText) {
                    k.tween(helpText.opacity, 1, 0.8, (val) => {
                        if (helpText) helpText.opacity = val;
                    }).then(() => {
                        if (helpTextVisible && helpText) {
                            k.tween(helpText.opacity, 0.3, 0.8, (val) => {
                                if (helpText) helpText.opacity = val;
                            }).then(() => {
                                if (helpTextVisible) {
                                    blinkTween();
                                }
                            });
                        }
                    });
                }
            };
            blinkTween();
        }
        
        function hideHelpText() {
            helpTextVisible = false;
            if (helpText) {
                helpText.destroy();
                helpText = null;
            }
            if (helpTextTimer) {
                clearTimeout(helpTextTimer);
                helpTextTimer = null;
            }
        }
        
        const dialogKeyHandler = (e) => {
            if (!isDialogActive) return;
            
            if (e.type === 'keydown') {
                if (e.code === 'Space' && !isShiftTutorial) {
                    e.preventDefault();
                    hideHelpText();
                    
                    currentDialogIndex++;
                    if (currentDialogIndex >= dialogData.length) {
                        isShiftTutorial = true;
                        currentDialogIndex = 0;
                        showCurrentDialog();
                    } else {
                        showCurrentDialog();
                    }
                } else if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && isShiftTutorial) {
                    e.preventDefault();
                    hideHelpText();
                    
                    currentDialogIndex++;
                    if (currentDialogIndex >= shiftDialogData.length) {
                        endDialog();
                    } else {
                        showCurrentDialog();
                    }
                }
            }
        };
        
        function endDialog() {
            console.log("üé≠ ÎåÄÌôî Ï¢ÖÎ£å");
            isDialogActive = false;
            hideHelpText();
            
            document.removeEventListener('keydown', dialogKeyHandler);
            document.removeEventListener('keyup', dialogKeyHandler);
            
            const allDialogElements = k.get("tutorialDialog");
            allDialogElements.forEach(element => {
                if (element.opacity !== undefined) {
                    k.tween(element.opacity, 0, 1, (val) => {
                        element.opacity = val;
                    });
                }
            });
            
            k.wait(1, () => {
                k.destroyAll("tutorialDialog");
                showFinalWellDoneMessage();
            });
        }
        
        document.addEventListener('keydown', dialogKeyHandler);
        document.addEventListener('keyup', dialogKeyHandler);
        
        createDialogBox();
    }

    function showFinalWellDoneMessage() {
        tutorialStep = 8;
        
        const finalWellDone = k.add([
            k.text("ÏûòÌñàÏäµÎãàÎã§!", {
                font: "galmuri",
                size: 28,
                align: "center"
            }),
            k.color(50, 200, 50),
            k.pos(k.center().x, k.height() - 120),
            k.anchor("center"),
            k.opacity(0),
            k.z(10),
            k.fixed(),
        ]);
        
        k.tween(finalWellDone.opacity, 1, 1, (val) => {
            finalWellDone.opacity = val;
        }).then(() => {
            k.wait(2, () => {
                k.tween(finalWellDone.opacity, 0, 1, (val) => {
                    finalWellDone.opacity = val;
                }).then(() => {
                    finalWellDone.destroy();
                    showTutorialCompleteMessage();
                });
            });
        });
    }

    function showTutorialCompleteMessage() {
        tutorialStep = 9;
        
        const completeText = k.add([
            k.text("Ìäú ÌÜ† Î¶¨ Ïñº ÏùÑ  Î™® Îëê  Îßà Ïπò ÏÖ® Ïäµ Îãà Îã§ .", { 
                size: 26,
                font: "galmuri"
            }),
            k.anchor("center"),
            k.pos(k.center().x, k.center().y),
            k.color(111, 111, 111),
            k.opacity(0),
            k.z(10),
            k.fixed(),
        ]);
        
        k.tween(completeText.opacity, 1, 1, (val) => {
            completeText.opacity = val;
        }).then(() => {
            k.wait(3, () => {
                k.tween(completeText.opacity, 0, 1, (val) => {
                    completeText.opacity = val;
                }).then(() => {
                    completeText.destroy();
                    console.log("üéâ ÌäúÌÜ†Î¶¨Ïñº ÏôÑÏ†ÑÌûà Ï¢ÖÎ£å!");
                    // ÌïÑÏöîÏãú Îã§Î•∏ Ïî¨ÏúºÎ°ú Ïù¥Îèô
                    // k.go("prologue");
                });
            });
        });
    }

    // ÌÇ§ ÏûÖÎ†• Ï≤òÎ¶¨
    documentKeyHandler = (e) => {
        console.log(`üéÆ Key event: ${e.code}, type: ${e.type}, tutorialStep: ${tutorialStep}`);
        
        if (tutorialStep !== 1 && tutorialStep !== 4 && tutorialStep !== 7) {
            if (e.type === 'keyup') {
                keyStates = {
                    left: false,
                    right: false,
                    up: false,
                    down: false
                };
            }
            return;
        }
        
        switch(e.code) {
            case 'ArrowLeft':
                keyStates.left = (e.type === 'keydown');
                e.preventDefault();
                console.log(`‚¨ÖÔ∏è Left key: ${keyStates.left}`);
                break;
            case 'ArrowRight':
                keyStates.right = (e.type === 'keydown');
                e.preventDefault();
                console.log(`‚û°Ô∏è Right key: ${keyStates.right}`);
                break;
            case 'ArrowUp':
                keyStates.up = (e.type === 'keydown');
                e.preventDefault();
                console.log(`‚¨ÜÔ∏è Up key: ${keyStates.up}`);
                break;
            case 'ArrowDown':
                keyStates.down = (e.type === 'keydown');
                e.preventDefault();
                console.log(`‚¨áÔ∏è Down key: ${keyStates.down}`);
                break;
            case 'Space':
                if (e.type === 'keydown' && (tutorialStep === 4 || tutorialStep === 7) && isNearNPC) {
                    e.preventDefault();
                    console.log(`üîç Ïä§ÌéòÏù¥Ïä§Î∞î Ïù¥Î≤§Ìä∏! tutorialStep: ${tutorialStep}`);
                    
                    if (tutorialStep === 4) {
                        handleLetterInteraction();
                    } else if (tutorialStep === 7) {
                        handleNPCInteraction();
                    }
                }
                break;
        }
    };

    document.addEventListener('keydown', documentKeyHandler);
    document.addEventListener('keyup', documentKeyHandler);

    // Kaboom Ïä§ÌéòÏù¥Ïä§Î∞î Ïù¥Î≤§Ìä∏
    k.onKeyPress("space", () => {
        if ((tutorialStep === 4 || tutorialStep === 7) && isNearNPC) {
            if (tutorialStep === 4) {
                handleLetterInteraction();
            } else if (tutorialStep === 7) {
                handleNPCInteraction();
            }
        }
    });

    // Î©îÏù∏ ÏóÖÎç∞Ïù¥Ìä∏ Î£®ÌîÑ
    k.onUpdate(() => {
        if (!player || !npc || (tutorialStep !== 4 && tutorialStep !== 7 && tutorialStep !== 1)) return;
        
        // Ïù¥Îèô Ï≤òÎ¶¨ (tutorialStep 1ÏóêÏÑúÎßå)
        if (tutorialStep === 1 && player) {
            const deltaTime = k.dt() * 1000;
            let isMoving = false;
            const moveVector = k.vec2(0, 0);
            
            if (keyStates.left) {
                moveVector.x -= MOVE_SPEED * k.dt();
                updateDirectionTime('left', deltaTime);
                isMoving = true;
            }
            if (keyStates.right) {
                moveVector.x += MOVE_SPEED * k.dt();
                updateDirectionTime('right', deltaTime);
                isMoving = true;
            }
            if (keyStates.up) {
                moveVector.y -= MOVE_SPEED * k.dt();
                updateDirectionTime('up', deltaTime);
                isMoving = true;
            }
            if (keyStates.down) {
                moveVector.y += MOVE_SPEED * k.dt();
                updateDirectionTime('down', deltaTime);
                isMoving = true;
            }
            
            // Ïù¥Îèô Ï†úÌïú
            const newPos = player.pos.add(moveVector);
            const distanceFromCenter = newPos.dist(k.vec2(CENTER_X, CENTER_Y));
            
            if (distanceFromCenter <= MOVE_RADIUS) {
                player.pos = newPos;
                hasPlayerMoved = true;
            }
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖò Ï≤òÎ¶¨
            if (isMoving) {
                let direction = "down";
                
                if (keyStates.up) {
                    direction = "up";
                } else if (keyStates.down) {
                    direction = "down";
                } else if (keyStates.left) {
                    direction = "left";
                } else if (keyStates.right) {
                    direction = "right";
                }
                
                if (currentAnimDirection !== direction || !isCurrentlyMoving) {
                    player.play(`player-walk-${direction}`);
                    currentAnimDirection = direction;
                    isCurrentlyMoving = true;
                }
            } else {
                if (isCurrentlyMoving) {
                    player.play(`player-idle-${currentAnimDirection}`);
                    isCurrentlyMoving = false;
                }
            }
        }
        
        // ÏÉÅÌò∏ÏûëÏö© Í∞êÏßÄ
        if ((tutorialStep === 4 || tutorialStep === 7) && player && npc) {
            const distance = player.pos.dist(npc.pos);
            
            if (distance <= 100) {
                if (!isNearNPC) {
                    isNearNPC = true;
                    console.log("üí¨ NPCÏóê Í∞ÄÍπåÏõåÏßê");
                    
                    if (exclamationMark) {
                        exclamationMark.destroy();
                    }
                    exclamationMark = k.add([
                        k.sprite("main-assets", { frame: 5777 }),
                        k.pos(npc.pos.x, npc.pos.y - 60),
                        k.anchor("center"),
                        k.scale(2),
                        k.z(1000),
                        "interaction-indicator"
                    ]);
                    
                    // ÌïòÌä∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
                    const originalY = exclamationMark.pos.y;
                    const floatTween = () => {
                        if (exclamationMark) {
                            k.tween(exclamationMark.pos.y, originalY - 10, 1, (val) => {
                                if (exclamationMark) exclamationMark.pos.y = val;
                            }).then(() => {
                                if (exclamationMark) {
                                    k.tween(exclamationMark.pos.y, originalY, 1, (val) => {
                                        if (exclamationMark) exclamationMark.pos.y = val;
                                    }).then(() => {
                                        if (exclamationMark) {
                                            floatTween();
                                        }
                                    });
                                }
                            });
                        }
                    };
                    floatTween();
                }
            } else {
                if (isNearNPC) {
                    isNearNPC = false;
                    console.log("üö∂ NPCÏóêÏÑú Î©ÄÏñ¥Ïßê");
                    
                    if (exclamationMark) {
                        exclamationMark.destroy();
                        exclamationMark = null;
                    }
                }
            }
        }
    });

    // Ïî¨ Ï†ïÎ¶¨
    k.onSceneLeave(() => {
        document.body.style.backgroundColor = '';
        
        if (documentKeyHandler) {
            document.removeEventListener('keydown', documentKeyHandler);
            document.removeEventListener('keyup', documentKeyHandler);
        }
        
        k.destroyAll("tutorialDialog");
        
        const fadeOverlays = document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10000"]');
        fadeOverlays.forEach(overlay => {
            if (overlay.parentNode) {
                document.body.removeChild(overlay);
            }
        });
        console.log("‚úÖ Tutorial Ïî¨ Ï¢ÖÎ£å");
    });
}
