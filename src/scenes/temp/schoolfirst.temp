import { createUIManager } from "../systems/uiManager.js";
import {
    generatePlayerComponents,
    setPlayerControls,
    watchPlayerHealth,
} from "../entities/player.js";
import { generateNoteComponents } from "../entities/note.js";
import { gameState } from "../state/stateManagers.js";
import { fadeInBGM } from "../utils.js";

import {
    colorizeBackground,
    fetchMapData,
    drawBoundaries,
    onAttacked,
    onCollideWithPlayer,
    setupMainMenuShortcut,
} from "../utils.js";

import noteDialogues from "../content/temp/noteDialogue.js";
import objectDialogues from "../content/objectDialogue.js";
import { dialog } from "../uiComponents/dialog.js";
import { toggleLocale, toggleMute, initializeQuestBubbles, updateQuestBubbles } from "../utils.js";

export default async function schoolfirst(k) {
    console.log("ğŸ« schoolfirst scene ì‹œì‘");

    fadeInBGM(k, "rpg-first-bgm"); // ìˆ˜ì •ëœ ë¶€ë¶„: house-bgm â†’ rpg-first-bgm

    const previousScene = gameState.getPreviousScene();

    // ì–¸ì–´ë¥¼ í•œêµ­ì–´ë¡œ ì„¤ì •
    gameState.setLocale("korean");

    // ë°°ê²½ì„ ê²€ì€ìƒ‰ìœ¼ë¡œ ì„¤ì •
    colorizeBackground(k, 0, 0, 0);
    const mapData = await fetchMapData("./assets/images/schoolfirst.json");
    const map = k.add([k.pos(0, 0)]);

    const entities = {
        player: null,
        students: [],
        letters: [],
    };
    const layers = mapData.layers;

    // spawnpoint ë ˆì´ì–´ë¥¼ ë¨¼ì € ì²˜ë¦¬í•˜ì—¬ í”Œë ˆì´ì–´ë¥¼ ìƒì„±
    for (const layer of layers) {
        if (layer.name === "spawnpoint") {
            // spawnpoint ë ˆì´ì–´ëŠ” ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬í–ˆìœ¼ë¯€ë¡œ ê±´ë„ˆë›°ê¸°
            continue;
        }
    }

    // ì´ì œ boundaries ë ˆì´ì–´ ì²˜ë¦¬
    for (const layer of layers) {
        if (layer.name === "boundaries") {
            // boundaries ë ˆì´ì–´ì—ì„œ íŠ¹ë³„í•œ ì˜¤ë¸Œì íŠ¸ë“¤ ì²˜ë¦¬
            for (const object of layer.objects) {
                if (
                    [
                        "locker",
                        "elevator1",
                        "plant1",
                        "plant2",
                        "plant3",
                        "shelf1",
                        "shelf2",
                        "bulletin1",
                        "door_store",
                        "door_wc1",
                        "stair_to_second",
                        "exit_to_front",
                        "window",
                        "cam", // ì¶”ê°€ëœ ë¶€ë¶„
                        "director",
                        "facil",
                    ].includes(object.name)
                ) {
                    const objectType = object.name;

                    // stair_to_secondëŠ” íŠ¹ë³„íˆ ì²˜ë¦¬ - schoolsecondë¡œ ì´ë™
                    if (objectType === "stair_to_second") {
                        const stairToSecondEntity = map.add([
                            k.rect(object.width, object.height),
                            k.area(),
                            k.body({ isStatic: true }),
                            k.pos(object.x, object.y + 16),
                            k.opacity(0),
                            "stair_to_second",
                            "interactive-object",
                            { objectType: "stair_to_second" },
                        ]);

                        stairToSecondEntity.onCollide("player", () => {
                            console.log(
                                "ğŸšª stair_to_second ì¶©ëŒ - schoolsecondë¡œ ì´ë™"
                            );
                            // ìˆ˜ì •ëœ ë¶€ë¶„: 2ì¸µ ì§„ì… ì‹œ íš¨ê³¼ìŒ ì¶”ê°€
                            k.play("boop-sfx");
                            gameState.setPreviousScene("schoolfirst");
                            k.go("schoolsecond");
                        });
                        continue;
                    }

                    // exit_to_frontëŠ” íŠ¹ë³„íˆ ì²˜ë¦¬ - schoolfrontë¡œ ì´ë™
                    if (objectType === "exit_to_front") {
                        const exitToFrontEntity = map.add([
                            k.rect(object.width, object.height),
                            k.area(),
                            k.body({ isStatic: true }),
                            k.pos(object.x, object.y + 16),
                            k.opacity(0),
                            "exit_to_front",
                            "interactive-object",
                            { objectType: "exit_to_front" },
                        ]);

                        exitToFrontEntity.onCollide("player", () => {
                            console.log(
                                "ğŸšª exit_to_front ì¶©ëŒ - schoolfrontë¡œ ì´ë™"
                            );
                            // ìˆ˜ì •ëœ ë¶€ë¶„: 1ì¸µì—ì„œ ì •ë¬¸ìœ¼ë¡œ ì´ë™ ì‹œ íš¨ê³¼ìŒ ì¶”ê°€
                            k.play("boop-sfx");
                            gameState.setPreviousScene("schoolfirst");
                            k.go("schoolfront");
                        });
                        continue;
                    }

                    // directorì™€ facilì˜ íŠ¹ë³„í•œ ì²˜ë¦¬
                    if (objectType === "director" || objectType === "facil") {
                        const adjustedWidth = Math.round(object.width * 1.05); // ë„ˆë¹„ 5% ì¦ê°€
                        const adjustedY = object.y + 16 - 10; // yì¢Œí‘œ 10ë§Œí¼ ìœ„ë¡œ ì´ë™
                        
                        const npcEntity = map.add([
                            k.rect(adjustedWidth, object.height),
                            k.area(),
                            k.body({ isStatic: true }),
                            k.pos(object.x, adjustedY),
                            k.opacity(0),
                            objectType,
                            "interactive-object",
                            { objectType },
                        ]);

                        // NPC ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ
                        npcEntity.onCollideUpdate("player", (player) => {
                            const locale = gameState.getLocale();
                            const content = objectDialogues[locale]?.[
                                objectType
                            ] || [
                                `Hello! I'm ${objectType}!`,
                                `ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” ${objectType}ì…ë‹ˆë‹¤!`,
                            ];

                            const speakerName =
                                objectDialogues.names[locale]?.[objectType] ||
                                objectType;

                            gameState.setInteractableObject(
                                npcEntity,
                                "npc",
                                {
                                    content: content,
                                    speakerName: speakerName,
                                    speakerImage: null,
                                }
                            );
                        });

                        // ì¶©ëŒì—ì„œ ë²—ì–´ë‚  ë•Œ ìƒí˜¸ì‘ìš© ê°ì²´ ì´ˆê¸°í™”
                        npcEntity.onCollideEnd("player", (player) => {
                            gameState.clearInteractableObject();
                        });
                        continue;
                    }

                    // Tiled ì¢Œí‘œê³„ì— ë§ì¶° ìœ„ì¹˜ ì¡°ì • (ë‹¤ë¥¸ ì¶©ëŒ ë°•ìŠ¤ë“¤ê³¼ ì¼ê´€ì„± ìœ ì§€)
                    const objectEntity = map.add([
                        k.rect(object.width, object.height),
                        k.area(),
                        k.body({ isStatic: true }),
                        k.pos(object.x, object.y + 16), // ì¼ë°˜ ì¶©ëŒ ë°•ìŠ¤ì™€ ê°™ì€ ì˜¤í”„ì…‹ ì ìš©
                        k.opacity(0),
                        objectType,
                        "interactive-object",
                        { objectType },
                    ]);

                    // ìˆ˜ì •ëœ ë¶€ë¶„: í”Œë ˆì´ì–´ì™€ì˜ ì¶©ëŒ ê°ì§€ (ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ)
                    objectEntity.onCollideUpdate("player", (player) => {
                        const locale = gameState.getLocale();
                        const content = objectDialogues[locale]?.[
                            objectType
                        ] || [
                            `This is ${objectType}`,
                            `ì´ê²ƒì€ ${objectType}ì…ë‹ˆë‹¤`,
                        ];

                        const speakerName =
                            objectDialogues.names[locale]?.[objectType] ||
                            objectType;

                        gameState.setInteractableObject(
                            objectEntity,
                            "object",
                            {
                                content: content,
                                speakerName: speakerName,
                                speakerImage: null,
                            }
                        );
                    });

                    // ì¶©ëŒì—ì„œ ë²—ì–´ë‚  ë•Œ ìƒí˜¸ì‘ìš© ê°ì²´ ì´ˆê¸°í™”
                    objectEntity.onCollideEnd("player", (player) => {
                        gameState.clearInteractableObject();
                    });
                }
            }

            const processedObjects = [
                "locker",
                "elevator1",
                "plant1",
                "plant2",
                "plant3",
                "shelf1",
                "shelf2",
                "bulletin1",
                "door_store",
                "door_wc1",
                "stair_to_second",
                "exit_to_front",
                "window",
                "cam", // ì¶”ê°€ëœ ë¶€ë¶„
                "director",
                "facil",
            ];

            drawBoundaries(k, map, layer, processedObjects);
            continue;
        }

        if (layer.name === "spawnpoint") {
            // ë¨¼ì € ëª¨ë“  ìŠ¤í° í¬ì¸íŠ¸ë¥¼ ìˆ˜ì§‘
            const spawnPoints = {};
            for (const object of layer.objects) {
                if (object.name === "player" || object.name === "player2") {
                    spawnPoints[object.name] = { x: object.x, y: object.y };
                }
            }

            // targetSpawn í™•ì¸í•´ì„œ ì ì ˆí•œ ìœ„ì¹˜ì— ìŠ¤í°
            const targetSpawn = gameState.getTargetSpawn() || "player";
            const spawnPos = spawnPoints[targetSpawn] || spawnPoints["player"];

            if (spawnPos) {
                entities.player = map.add(
                    generatePlayerComponents(k, k.vec2(spawnPos.x, spawnPos.y))
                );

                // ìŠ¤í° í›„ targetSpawn ì´ˆê¸°í™”
                gameState.setTargetSpawn(null);
            }

            for (const object of layer.objects) {
                // í”Œë ˆì´ì–´ ìŠ¤í°ì€ ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬í–ˆìœ¼ë¯€ë¡œ ê±´ë„ˆë›°ê¸°
                if (object.name === "player" || object.name === "player2") {
                    continue;
                }

                if (object.name.startsWith("student")) {
                    // student1, student2, student3, student4 ì²˜ë¦¬
                    const studentType = object.name; // student1, student2, etc.

                    const student = map.add([
                        k.sprite("main-assets", {
                            anim: studentType, // main.jsì— ì •ì˜ëœ ì• ë‹ˆë©”ì´ì…˜ ì‚¬ìš©
                        }),
                        k.area({
                            shape: new k.Rect(k.vec2(0), 24, 24), // 24x24 í”½ì…€ ì¶©ëŒ ì˜ì—­
                        }),
                        k.body({ isStatic: true }),
                        k.pos(object.x, object.y),
                        k.z(1), // í”Œë ˆì´ì–´ë³´ë‹¤ ì•„ë˜, ë°°ê²½ë³´ë‹¤ ìœ„ì— ë°°ì¹˜
                        "student",
                        { studentType },
                    ]);

                    entities.students.push(student);

                    // ì¶”ê°€ëœ ë¶€ë¶„: student1ì—ë§Œ ë§í’ì„  ì¶”ê°€ (ì„ì‹œë¡œ ì œê±° - ì—ëŸ¬ í•´ê²° í›„ ë‹¤ì‹œ ì¶”ê°€ ì˜ˆì •)
                    // if (studentType === "student1") {
                    //     const bubble = map.add([
                    //         k.sprite("main-assets", { frame: 874 }),
                    //         k.pos(student.pos.x, student.pos.y - 50),
                    //         k.anchor("bottom"),
                    //         k.scale(0.8),
                    //         k.z(20),
                    //         k.opacity(1.0),
                    //         "speech-bubble"
                    //     ]);

                    //     let time = 0;
                    //     bubble.onUpdate(() => {
                    //         time += k.dt();
                    //         bubble.pos.x = student.pos.x;
                    //         bubble.pos.y = student.pos.y - 50 + Math.sin(time * 3) * 3;
                    //     });

                    //     student.speechBubble = bubble;
                    // }

                    // ìˆ˜ì •ëœ ë¶€ë¶„: í•™ìƒ ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ
                    student.onCollideUpdate("player", (player) => {
                        const locale = gameState.getLocale();
                        const content = npcDialogues[locale]?.[studentType] || [
                            `Hello! I'm ${studentType}!`,
                            `ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” ${studentType}ì…ë‹ˆë‹¤!`,
                        ];

                        const speakerName =
                            npcDialogues.names[locale]?.[studentType] ||
                            studentType;

                        gameState.setInteractableObject(student, "student", {
                            content: content,
                            speakerName: speakerName,
                            speakerImage: null,
                        });
                    });

                    student.onCollideEnd("player", (player) => {
                        gameState.clearInteractableObject();
                    });
                    continue;
                }

                if (object.name.startsWith("letter")) {
                    // letter1, letter2 ì²˜ë¦¬
                    const letterType = object.name;
                    const letterId =
                        object.properties?.find((p) => p.name === "letterId")
                            ?.value || letterType;

                    const letter = map.add([
                        k.sprite("main-assets", {
                            anim: letterType, // main.jsì— ì •ì˜ëœ ì• ë‹ˆë©”ì´ì…˜ ì‚¬ìš©
                        }),
                        k.area(),
                        k.body({ isStatic: true }),
                        k.pos(object.x, object.y),
                        k.z(1), // í”Œë ˆì´ì–´ë³´ë‹¤ ì•„ë˜, ë°°ê²½ë³´ë‹¤ ìœ„ì— ë°°ì¹˜
                        "letter",
                        { letterId, letterType },
                    ]);

                    entities.letters.push(letter);

                    // ìˆ˜ì •ëœ ë¶€ë¶„: letter ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ
                    letter.onCollideUpdate("player", (player) => {
                        const locale = gameState.getLocale();
                        const content = objectDialogues[locale]?.[
                            letterType
                        ] || [
                            `This is ${letterType}`,
                            `ì´ê²ƒì€ ${letterType}ì…ë‹ˆë‹¤`,
                        ];

                        const speakerName =
                            objectDialogues.names[locale]?.[letterType] ||
                            letterType;

                        gameState.setInteractableObject(letter, "letter", {
                            content: content,
                            speakerName: speakerName,
                            speakerImage: null,
                        });
                    });

                    letter.onCollideEnd("player", (player) => {
                        gameState.clearInteractableObject();
                    });
                    continue;
                }

                // facil ì²˜ë¦¬
                if (object.name === "facil") {
                    const facil = map.add([
                        k.sprite("main-assets", {
                            anim: "facil", // main.jsì— ì •ì˜ëœ ì• ë‹ˆë©”ì´ì…˜ ì‚¬ìš©
                        }),
                        k.area(),
                        k.body({ isStatic: true }),
                        k.pos(object.x, object.y),
                        k.z(1), // í”Œë ˆì´ì–´ë³´ë‹¤ ì•„ë˜, ë°°ê²½ë³´ë‹¤ ìœ„ì— ë°°ì¹˜
                        "facil",
                        { npcType: "facil" },
                    ]);

                    // ìˆ˜ì •ëœ ë¶€ë¶„: facil ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ
                    facil.onCollideUpdate("player", (player) => {
                        const locale = gameState.getLocale();
                        const content = npcDialogues[locale]?.["facil"] || [
                            "Hello! I'm the vice principal.",
                            "ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” êµê°ì…ë‹ˆë‹¤.",
                        ];

                        const speakerName =
                            npcDialogues.names[locale]?.["facil"] ||
                            "Vice Principal";

                        gameState.setInteractableObject(facil, "npc", {
                            content: content,
                            speakerName: speakerName,
                            speakerImage: null,
                        });
                    });

                    facil.onCollideEnd("player", (player) => {
                        gameState.clearInteractableObject();
                    });
                    continue;
                }

                // ê¸°ì¡´ note ì²˜ë¦¬ëŠ” ìœ ì§€ (í˜¸í™˜ì„±ì„ ìœ„í•´)
                if (object.name === "note") {
                    const noteIdProp = object.properties?.find(
                        (p) => p.name === "noteId"
                    )?.value;

                    const note = map.add(
                        generateNoteComponents(
                            k,
                            k.vec2(object.x, object.y),
                            noteIdProp
                        )
                    );

                    // ìˆ˜ì •ëœ ë¶€ë¶„: note ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ
                    note.onCollideUpdate("player", (player) => {
                        const locale = gameState.getLocale();
                        const content = noteDialogues[locale][note.noteId];

                        gameState.setInteractableObject(note, "note", {
                            content: content,
                            speakerName: null,
                            speakerImage: null,
                        });
                    });

                    note.onCollideEnd("player", (player) => {
                        gameState.clearInteractableObject();
                    });
                }
            }
            continue;
        }

        // Handle regular tile layers with main-assets sprite
        if (layer.data) {
            let nbOfDrawnTiles = 0;
            const tilePos = k.vec2(0, 0);
            for (const tile of layer.data) {
                if (nbOfDrawnTiles % layer.width === 0) {
                    tilePos.x = 0;
                    tilePos.y += mapData.tileheight;
                } else {
                    tilePos.x += mapData.tilewidth;
                }

                nbOfDrawnTiles++;

                if (tile === 0) continue;

                // upmost ë ˆì´ì–´ëŠ” ìºë¦­í„°ë³´ë‹¤ ìœ„ì— ë°°ì¹˜ (z=3), cha ë ˆì´ì–´ëŠ” ìºë¦­í„°ì™€ ê°™ì€ ë†’ì´ (z=1), ë‹¤ë¥¸ íƒ€ì¼ì€ ê¸°ë³¸ (z=0)
                let zIndex = 0;
                if (layer.name === "upmost") {
                    zIndex = 3;
                } else if (layer.name === "cha") {
                    zIndex = 1;
                }

                // Use main-assets sprite instead of assets
                map.add([
                    k.sprite("main-assets", { frame: tile - 1 }),
                    k.pos(tilePos),
                    k.z(zIndex),
                    k.offscreen(),
                ]);
            }
            continue;
        }
    }

    // í”Œë ˆì´ì–´ê°€ ìŠ¤í°ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ê¸°ë³¸ ìœ„ì¹˜ì— ìƒì„±
    if (!entities.player) {
        console.log(
            "âš ï¸ í”Œë ˆì´ì–´ ìŠ¤í° í¬ì¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ ê¸°ë³¸ ìœ„ì¹˜ì— ìƒì„±í•©ë‹ˆë‹¤."
        );
        entities.player = map.add(
            generatePlayerComponents(k, k.vec2(400, 400)) // ë§µ ì¤‘ì•™ ê·¼ì²˜ì— ìŠ¤í°
        );
    }

    setPlayerControls(k, entities.player);

    k.camScale(3);
    k.camPos(entities.player.worldPos());
    k.onUpdate(async () => {
        if (entities.player.pos.dist(k.camPos()) > 3) {
            await k.tween(
                k.camPos(),
                entities.player.worldPos(),
                0.15,
                (newPos) => k.camPos(newPos),
                k.easings.linear
            );
        }
    });

    // Studentë‚˜ letterëŠ” ì •ì ì´ë¯€ë¡œ ë³„ë„ AI ì²˜ë¦¬ ë¶ˆí•„ìš”
    // í•„ìš”ì‹œ ì—¬ê¸°ì— studentë“¤ì˜ ì• ë‹ˆë©”ì´ì…˜ì´ë‚˜ ìƒí˜¸ì‘ìš© ë¡œì§ ì¶”ê°€ ê°€ëŠ¥

    // ì¶”ê°€ëœ ë¶€ë¶„: í€˜ìŠ¤íŠ¸ ë§í’ì„  ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    initializeQuestBubbles(k, entities.students, map);

    const uiManager = createUIManager(k);
    uiManager.initialize(k);
    
    // ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ì”¬ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ìƒì„±)
    if (k.inventoryManager) {
        console.log("ğŸ“¦ ì”¬ì—ì„œ ì¸ë²¤í† ë¦¬ ìƒì„± ì¤‘...");
        k.inventoryManager.create();
    }
    
    watchPlayerHealth(k);

    let isLocaleLocked = { value: false };
    let isMuteLocked = { value: false };

    // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
    k.onKeyPress("l", () => {
        toggleLocale(k, gameState, isLocaleLocked);
    });

    // ìˆ˜ì •ëœ ë¶€ë¶„: í•œê¸€ ìíŒ 'ã…£' (lí‚¤)ë„ ì–¸ì–´ ë³€ê²½
    k.onKeyPress("ã…£", () => {
        toggleLocale(k, gameState, isLocaleLocked);
    });

    k.onKeyPress("m", () => {
        toggleMute(k, gameState, isMuteLocked);
    });

    // ìˆ˜ì •ëœ ë¶€ë¶„: í•œê¸€ ìíŒ 'ã…¡' (mí‚¤)ë„ ìŒì†Œê±° í† ê¸€
    k.onKeyPress("ã…¡", () => {
        toggleMute(k, gameState, isMuteLocked);
    });

    // ê²Œì„íŒ¨ë“œ ì»¨íŠ¸ë¡¤ (L/R ìˆ„ë” ë²„íŠ¼)
    k.onGamepadButtonPress("lshoulder", () => {
        // Lë²„íŠ¼
        console.log("ğŸ® Lë²„íŠ¼ ëˆŒë¦¼ - ì–¸ì–´ ë³€ê²½");
        toggleLocale(k, gameState, isLocaleLocked);
    });

    k.onGamepadButtonPress("rshoulder", () => {
        // Rë²„íŠ¼
        console.log("ğŸ® Rë²„íŠ¼ ëˆŒë¦¼ - ìŒì†Œê±° í† ê¸€");
        toggleMute(k, gameState, isMuteLocked);
    });

    // ê²Œì„íŒ¨ë“œ íŠ¸ë¦¬ê±° ë²„íŠ¼ë„ ì¶”ê°€ (ì„ íƒì‚¬í•­)
    k.onGamepadButtonPress("ltrigger", () => {
        // L2 íŠ¸ë¦¬ê±°
        console.log("ğŸ® L2 íŠ¸ë¦¬ê±° ëˆŒë¦¼ - ì–¸ì–´ ë³€ê²½");
        toggleLocale(k, gameState, isLocaleLocked);
    });

    k.onGamepadButtonPress("rtrigger", () => {
        // R2 íŠ¸ë¦¬ê±°
        console.log("ğŸ® R2 íŠ¸ë¦¬ê±° ëˆŒë¦¼ - ìŒì†Œê±° í† ê¸€");
        toggleMute(k, gameState, isMuteLocked);
    });

    // 1ë²ˆ í‚¤ë¡œ ë©”ì¸ ë©”ë‰´ ì´ë™
    setupMainMenuShortcut(k, gameState);
}
