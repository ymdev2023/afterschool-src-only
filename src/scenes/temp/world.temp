import { healthBar } from "../../uiComponents/healthbar.js";
import {
    generatePlayerComponents,
    setPlayerControls,
    watchPlayerHealth,
} from "../../entities/player.js";
import { generateNoteComponents } from "../../entities/note.js";
import { gameState } from "../../state/stateManagers.js";
import { fadeInBGM } from "../../utils.js";

import {
    colorizeBackground,
    fetchMapData,
    drawBoundaries,
    onAttacked,
    onCollideWithPlayer,
} from "../../utils.js";

import noteDialogues from "../content/noteDialogue.js";
import objectDialogues from "../../content/objectDialogue.js";
import { dialog } from "../../uiComponents/dialog.js";
import { toggleLocale, toggleMute } from "../../utils.js";

export default async function world(k) {
    fadeInBGM(k, "rpg-front-bgm"); // ìˆ˜ì •ëœ ë¶€ë¶„: world-bgm â†’ rpg-front-bgm

    const previousScene = gameState.getPreviousScene();

    // ì–¸ì–´ë¥¼ í•œêµ­ì–´ë¡œ ì„¤ì •
    gameState.setLocale("korean");

    colorizeBackground(k, 238, 246, 169);
    const mapData = await fetchMapData("./assets/images/temp/testasset.json"); // ìˆ˜ì •ëœ ë¶€ë¶„: images í´ë”ë¡œ ì´ë™
    const map = k.add([k.pos(0, 0)]);

    const entities = {
        player: null,
        students: [],
        letters: [],
    };
    const layers = mapData.layers;
    for (const layer of layers) {
        if (layer.name === "boundaries") {
            // boundaries ë ˆì´ì–´ì—ì„œ íŠ¹ë³„í•œ ì˜¤ë¸Œì íŠ¸ë“¤ ì²˜ë¦¬
            for (const object of layer.objects) {
                if (["guryeong", "front_gate"].includes(object.name)) {
                    const objectType = object.name;

                    // Tiled ì¢Œí‘œê³„ì— ë§ì¶° ìœ„ì¹˜ ì¡°ì • (ë‹¤ë¥¸ ì¶©ëŒ ë°•ìŠ¤ë“¤ê³¼ ì¼ê´€ì„± ìœ ì§€)
                    const objectEntity = map.add([
                        k.rect(object.width, object.height),
                        k.area(),
                        k.body({ isStatic: true }),
                        k.pos(object.x, object.y + 16), // ì¼ë°˜ ì¶©ëŒ ë°•ìŠ¤ì™€ ê°™ì€ ì˜¤í”„ì…‹ ì ìš©
                        k.opacity(0),
                        objectType,
                        "interactive-object",
                        { objectType },
                    ]);

                    // í”Œë ˆì´ì–´ì™€ì˜ ì¶©ëŒ ê°ì§€
                    objectEntity.onCollide("player", async (player) => {
                        console.log(`ğŸ¯ ${objectType} ì¶©ëŒ ê°ì§€!`);
                        k.play("bubble-sfx");

                        const locale = gameState.getLocale();
                        const content = objectDialogues[locale]?.[
                            objectType
                        ] || [
                            `This is ${objectType}`,
                            `ì´ê²ƒì€ ${objectType}ì…ë‹ˆë‹¤`,
                        ];
                        const font =
                            locale === "korean" ? "galmuri" : "gameboy";

                        // ì˜¤ë¸Œì íŠ¸ ì´ë¦„ì„ objectDialogueì—ì„œ ê°€ì ¸ì˜¤ê¸°
                        const speakerName =
                            objectDialogues.names[locale]?.[objectType] ||
                            objectType;

                        await dialog(k, k.vec2(250, 500), content, {
                            font,
                            speakerName,
                            speakerImage: null,
                        });
                    });

                    // í”Œë ˆì´ì–´ê°€ ì˜ì—­ì— ë“¤ì–´ì˜¬ ë•Œë„ ê°ì§€
                    objectEntity.onCollideUpdate("player", (player) => {
                        // ì—°ì†ì ì¸ ì¶©ëŒ ê°ì§€ - í•„ìš”ì‹œ ì‚¬ìš©
                    });
                }
            }

            drawBoundaries(k, map, layer);
            continue;
        }

        if (layer.name === "spawnpoint") {
            for (const object of layer.objects) {
                if (
                    object.name === "player-dungeon" &&
                    previousScene === "dungeon"
                ) {
                    entities.player = map.add(
                        generatePlayerComponents(k, k.vec2(object.x, object.y))
                    );
                    continue;
                }

                if (
                    object.name === "player" &&
                    (!previousScene || previousScene === "house")
                ) {
                    entities.player = map.add(
                        generatePlayerComponents(k, k.vec2(object.x, object.y))
                    );
                    continue;
                }

                if (object.name.startsWith("student")) {
                    // student1, student2, student3, student4 ì²˜ë¦¬
                    const studentType = object.name; // student1, student2, etc.

                    const student = map.add([
                        k.sprite("test-assets", {
                            anim: studentType, // main.jsì— ì •ì˜ëœ ì• ë‹ˆë©”ì´ì…˜ ì‚¬ìš©
                        }),
                        k.area(),
                        k.body({ isStatic: true }),
                        k.pos(object.x, object.y),
                        k.z(1), // í”Œë ˆì´ì–´ë³´ë‹¤ ì•„ë˜, ë°°ê²½ë³´ë‹¤ ìœ„ì— ë°°ì¹˜
                        "student",
                        { studentType },
                    ]);

                    entities.students.push(student);

                    student.onCollide("player", async (player) => {
                        k.play("bubble-sfx");

                        const locale = gameState.getLocale();
                        const content = npcDialogues[locale]?.[studentType] || [
                            `Hello! I'm ${studentType}!`,
                            `ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” ${studentType}ì…ë‹ˆë‹¤!`,
                        ];
                        const font =
                            locale === "korean" ? "galmuri" : "gameboy";

                        // í•™ìƒ ì´ë¦„ì„ npcDialogueì—ì„œ ê°€ì ¸ì˜¤ê¸°
                        const speakerName =
                            npcDialogues.names[locale]?.[studentType] ||
                            studentType;

                        await dialog(k, k.vec2(250, 500), content, {
                            font,
                            speakerName,
                            speakerImage: null,
                        });
                    });
                    continue;
                }

                if (object.name.startsWith("letter")) {
                    // letter1, letter2 ì²˜ë¦¬
                    const letterType = object.name;
                    const letterId =
                        object.properties?.find((p) => p.name === "letterId")
                            ?.value || letterType;

                    const letter = map.add([
                        k.sprite("test-assets", {
                            anim: letterType, // main.jsì— ì •ì˜ëœ ì• ë‹ˆë©”ì´ì…˜ ì‚¬ìš©
                        }),
                        k.area(),
                        k.body({ isStatic: true }),
                        k.pos(object.x, object.y),
                        k.z(1), // í”Œë ˆì´ì–´ë³´ë‹¤ ì•„ë˜, ë°°ê²½ë³´ë‹¤ ìœ„ì— ë°°ì¹˜
                        "letter",
                        { letterId, letterType },
                    ]);

                    entities.letters.push(letter);

                    letter.onCollide("player", async (player) => {
                        k.play("bubble-sfx");

                        const locale = gameState.getLocale();
                        // objectDialogues ì‚¬ìš©
                        const content = objectDialogues[locale]?.[
                            letterType
                        ] || [
                            `This is ${letterType}`,
                            `ì´ê²ƒì€ ${letterType}ì…ë‹ˆë‹¤`,
                        ];
                        const font =
                            locale === "korean" ? "galmuri" : "gameboy";

                        // í¸ì§€ ì´ë¦„ì„ objectDialogueì—ì„œ ê°€ì ¸ì˜¤ê¸°
                        const speakerName =
                            objectDialogues.names[locale]?.[letterType] ||
                            letterType;

                        await dialog(k, k.vec2(250, 500), content, {
                            font,
                            speakerName,
                            speakerImage: null,
                        });
                    });
                    continue;
                }

                // ê¸°ì¡´ note ì²˜ë¦¬ëŠ” ìœ ì§€ (í˜¸í™˜ì„±ì„ ìœ„í•´)
                if (object.name === "note") {
                    const noteIdProp = object.properties?.find(
                        (p) => p.name === "noteId"
                    )?.value;

                    const note = map.add(
                        generateNoteComponents(
                            k,
                            k.vec2(object.x, object.y),
                            noteIdProp
                        )
                    );

                    note.onCollide("player", async (player) => {
                        k.play("bubble-sfx");

                        const locale = gameState.getLocale();
                        const content = noteDialogues[locale][note.noteId];
                        const font =
                            locale === "korean" ? "galmuri" : "gameboy";

                        await dialog(k, k.vec2(250, 500), content, { font });
                    });
                }
            }
            continue;
        }

        // Handle regular tile layers with test-assets sprite
        if (layer.data) {
            let nbOfDrawnTiles = 0;
            const tilePos = k.vec2(0, 0);
            for (const tile of layer.data) {
                if (nbOfDrawnTiles % layer.width === 0) {
                    tilePos.x = 0;
                    tilePos.y += mapData.tileheight;
                } else {
                    tilePos.x += mapData.tilewidth;
                }

                nbOfDrawnTiles++;

                if (tile === 0) continue;

                // upmost ë ˆì´ì–´ëŠ” ìºë¦­í„°ë³´ë‹¤ ìœ„ì— ë°°ì¹˜ (z=3), ë‹¤ë¥¸ íƒ€ì¼ì€ ê¸°ë³¸ (z=0)
                const zIndex = layer.name === "upmost" ? 3 : 0;

                // Use test-assets sprite instead of assets
                map.add([
                    k.sprite("test-assets", { frame: tile - 1 }),
                    k.pos(tilePos),
                    k.z(zIndex),
                    k.offscreen(),
                ]);
            }
            continue;
        }
    }

    setPlayerControls(k, entities.player);
    entities.player.onCollide("door-entrance", () => k.go("house"));
    entities.player.onCollide("dungeon-door-entrance", () => k.go("dungeon"));

    k.camScale(3);
    k.camPos(entities.player.worldPos());
    k.onUpdate(async () => {
        if (entities.player.pos.dist(k.camPos()) > 3) {
            await k.tween(
                k.camPos(),
                entities.player.worldPos(),
                0.15,
                (newPos) => k.camPos(newPos),
                k.easings.linear
            );
        }
    });

    // Studentë‚˜ letterëŠ” ì •ì ì´ë¯€ë¡œ ë³„ë„ AI ì²˜ë¦¬ ë¶ˆí•„ìš”
    // í•„ìš”ì‹œ ì—¬ê¸°ì— studentë“¤ì˜ ì• ë‹ˆë©”ì´ì…˜ì´ë‚˜ ìƒí˜¸ì‘ìš© ë¡œì§ ì¶”ê°€ ê°€ëŠ¥

    healthBar(k);
    watchPlayerHealth(k);

    let isLocaleLocked = { value: false };
    let isMuteLocked = { value: false };

    // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
    k.onKeyPress("l", () => {
        toggleLocale(k, gameState, isLocaleLocked);
    });

    k.onKeyPress("m", () => {
        toggleMute(k, gameState, isMuteLocked);
    });

    // ê²Œì„íŒ¨ë“œ ì»¨íŠ¸ë¡¤ (L/R ìˆ„ë” ë²„íŠ¼)
    k.onGamepadButtonPress("lshoulder", () => {
        // Lë²„íŠ¼
        console.log("ğŸ® Lë²„íŠ¼ ëˆŒë¦¼ - ì–¸ì–´ ë³€ê²½");
        toggleLocale(k, gameState, isLocaleLocked);
    });

    k.onGamepadButtonPress("rshoulder", () => {
        // Rë²„íŠ¼
        console.log("ğŸ® Rë²„íŠ¼ ëˆŒë¦¼ - ìŒì†Œê±° í† ê¸€");
        toggleMute(k, gameState, isMuteLocked);
    });

    // ê²Œì„íŒ¨ë“œ íŠ¸ë¦¬ê±° ë²„íŠ¼ë„ ì¶”ê°€ (ì„ íƒì‚¬í•­)
    k.onGamepadButtonPress("ltrigger", () => {
        // L2 íŠ¸ë¦¬ê±°
        console.log("ğŸ® L2 íŠ¸ë¦¬ê±° ëˆŒë¦¼ - ì–¸ì–´ ë³€ê²½");
        toggleLocale(k, gameState, isLocaleLocked);
    });

    k.onGamepadButtonPress("rtrigger", () => {
        // R2 íŠ¸ë¦¬ê±°
        console.log("ğŸ® R2 íŠ¸ë¦¬ê±° ëˆŒë¦¼ - ìŒì†Œê±° í† ê¸€");
        toggleMute(k, gameState, isMuteLocked);
    });
}
