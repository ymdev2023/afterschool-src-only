import { playerState } from "./state/stateManagers.js";
import { healthBar } from "./uiComponents/healthbar.js";
import { gameState } from "./state/stateManagers.js";

export function playAnimIfNotPlaying(gameObj, animName) {
    if (gameObj.curAnim() !== animName) {
        gameObj.play(animName);
    }
}

export function areAnyOfTheseKeysDown(k, keys) {
    for (const key of keys) {
        if (k.isKeyDown(key)) return true;
    }

    return false;
}

export function colorizeBackground(k, r, g, b) {
    k.add([
        k.rect(k.canvas.width, k.canvas.height),
        k.color(r, g, b),
        k.fixed(),
    ]);
}

export function drawTiles(k, map, layer, tileheight, tilewidth) {
    let nbOfDrawnTiles = 0;
    const tilePos = k.vec2(0, 0);
    for (const tile of layer.data) {
        if (nbOfDrawnTiles % layer.width === 0) {
            tilePos.x = 0;
            tilePos.y += tileheight;
        } else {
            tilePos.x += tilewidth;
        }

        nbOfDrawnTiles++;

        if (tile === 0) continue;

        map.add([
            k.sprite("assets", { frame: tile - 1 }),
            k.pos(tilePos),
            k.offscreen(),
        ]);
    }
}

export function drawBoundaries(k, map, layer, excludeNames = []) {
    let colliderCount = 0;
    for (const object of layer.objects) {
        // 이미 처리된 객체들은 제외
        if (excludeNames.includes(object.name)) {
            continue;
        }

        // 태그 우선순위: name > type > "wall"
        const tag = object.name !== "" ? object.name : object.type || "wall";

        // 충돌체 직접 생성
        const collider = map.add([
            k.rect(object.width, object.height),
            k.pos(object.x, object.y + 16),
            k.area(),
            k.body({ isStatic: true }),
            k.opacity(0),
            tag,
        ]);

        colliderCount++;
    }
}

export async function fetchMapData(mapPath) {
    return await (await fetch(mapPath)).json();
}

export function generateColliderBoxComponents(k, width, height, pos, tag) {
    return [
        k.rect(width, height),
        k.pos(pos.x, pos.y + 16),
        k.area(),
        k.body({ isStatic: true }),
        k.opacity(0),
        // k.offscreen() 제거 - 충돌체는 화면 밖에서도 유지되어야 함
        tag || "wall", // 태그가 없으면 기본값 "wall"
    ];
}

export async function blinkEffect(k, entity) {
    await k.tween(
        entity.opacity,
        0,
        0.1,
        (val) => (entity.opacity = val),
        k.easings.linear
    );
    await k.tween(
        entity.opacity,
        1,
        0.1,
        (val) => (entity.opacity = val),
        k.easings.linear
    );
}

export function onAttacked(k, entity) {
    entity.onCollide("swordHitBox", async () => {
        if (entity.isAttacking) return;

        if (entity.hp() <= 0) {
            k.destroy(entity);
        }

        await blinkEffect(k, entity);
        entity.hurt(1);
    });
}

export function onCollideWithPlayer(k, entity) {
    entity.onCollide("player", async (player) => {
        if (player.isAttacking) return;
        playerState.setHealth(playerState.getHealth() - entity.attackPower);
        k.destroyAll("healthContainer");
        healthBar(k, player);
        await blinkEffect(k, player);
    });
}

// 추가된 부분: BGM 볼륨 관리를 위한 전역 변수들
let originalBgmVolume = 0.4;
let currentBgmVolume = 0.4;
let bgmDuckingTimeouts = new Set();
let isDucked = false; // 수정된 부분: 덕킹 상태 추적

// 수정된 부분: BGM 볼륨을 20%로 확실하게 감소시키는 함수
export function duckBgm(k) {
    const bgmHandle = gameState.getBgmHandle();
    if (!bgmHandle || bgmHandle.paused) return;

    console.log("[DEBUG] BGM 덕킹 적용 - 원래 볼륨:", bgmHandle.volume);

    // 수정된 부분: 현재 볼륨을 저장하고 20%로 감소
    if (!isDucked) {
        originalBgmVolume = bgmHandle.volume; // 현재 실제 볼륨 저장
        const duckedVolume = originalBgmVolume * 0.2; // 20%로 감소
        bgmHandle.volume = duckedVolume;
        isDucked = true;

        console.log("[DEBUG] BGM 덕킹 완료 - 덕킹 후 볼륨:", duckedVolume);
    }
}

// 수정된 부분: BGM 볼륨을 정확히 원래대로 복구하는 함수
export function restoreBgm(k) {
    const bgmHandle = gameState.getBgmHandle();
    if (!bgmHandle || bgmHandle.paused) return;

    console.log("[DEBUG] BGM 덕킹 해제 - 현재 볼륨:", bgmHandle.volume);

    // 수정된 부분: 원래 볼륨으로 정확히 복구
    if (isDucked) {
        bgmHandle.volume = originalBgmVolume;
        isDucked = false;

        console.log(
            "[DEBUG] BGM 덕킹 해제 완료 - 복구된 볼륨:",
            originalBgmVolume
        );
    }
}

// 추가된 부분: SFX 재생 시 BGM 덕킹을 자동으로 처리하는 함수
export function playSfxWithDucking(k, soundKey, options = {}) {
    // BGM 볼륨 감소
    duckBgm(k);

    // SFX 재생
    const sfx = k.play(soundKey, options);

    // SFX 지속 시간 추정 (기본값: 2초)
    const estimatedDuration = options.estimatedDuration || 2.0;

    // SFX 끝날 때 BGM 볼륨 복구
    const timeoutId = setTimeout(() => {
        restoreBgm(k);
        bgmDuckingTimeouts.delete(timeoutId);
    }, estimatedDuration * 1000);

    bgmDuckingTimeouts.add(timeoutId);

    return sfx;
}

export function fadeInBGM(k, soundKey, targetVolume = 0.4, fadeSpeed = 0.002) {
    // 기존 BGM 정지
    const existingBgm = gameState.getBgmHandle();
    if (existingBgm) {
        existingBgm.stop();
    }

    // 수정된 부분: 덕킹 상태 초기화
    isDucked = false;
    originalBgmVolume = targetVolume;
    currentBgmVolume = targetVolume;

    console.log("[DEBUG] BGM 페이드인 시작 - 목표 볼륨:", targetVolume);

    // 새로운 BGM 재생 (시작은 0 볼륨)
    const music = k.play(soundKey, {
        volume: 0,
        loop: true,
    });

    // 수정된 부분: 전역 상태에 저장
    gameState.setBgmHandle(music);

    // 이미 음소거 상태라면 일시정지
    if (gameState.getIsMuted()) {
        music.paused = true;
    }

    let fadeVolume = 0;

    // 매 프레임마다 점점 볼륨 증가
    k.onUpdate(() => {
        if (fadeVolume < targetVolume) {
            fadeVolume += fadeSpeed;
            fadeVolume = Math.min(fadeVolume, targetVolume);
            music.volume = fadeVolume;
            // 수정된 부분: 덕킹 중이 아닐 때만 originalBgmVolume 업데이트
            if (!isDucked) {
                originalBgmVolume = fadeVolume;
            }
        }
    });
}
export function toggleLocale(k, gameState, isLockedRef) {
    if (isLockedRef.value) return;
    isLockedRef.value = true;

    playSfxWithDucking(k, "confirm-beep-sfx", { estimatedDuration: 0.8 });

    const current = gameState.getLocale();
    const next = current === "korean" ? "english" : "korean";
    gameState.setLocale(next);

    const msgText =
        next === "korean"
            ? "언어를 한국어로 변경합니다."
            : "Language changed to English";

    const msgFont = next === "korean" ? "galmuri" : "gameboy";

    const msg = k.add([
        k.text(msgText, {
            size: 20,
            font: msgFont,
        }),
        k.pos(k.center().x, k.height() - 40),
        k.anchor("center"),
        k.fixed(),
        { tag: "locale-notice" },
    ]);

    k.wait(1.5, () => {
        k.destroy(msg);
        isLockedRef.value = false;
    });
}

export function toggleMute(k, gameState, isLockedRef) {
    if (isLockedRef.value) return;
    isLockedRef.value = true;

    playSfxWithDucking(k, "confirm-beep-sfx", { estimatedDuration: 0.8 });

    // 수정된 부분: 전역 상태 사용
    const bgmHandle = gameState.getBgmHandle();
    if (bgmHandle) {
        bgmHandle.paused = !bgmHandle.paused;
        gameState.setIsMuted(bgmHandle.paused);
    }

    const isMuted = gameState.getIsMuted();
    const locale = gameState.getLocale();

    const msgText =
        locale === "korean"
            ? isMuted
                ? "오디오가 음소거되었습니다!"
                : "오디오 음소거가 해제되었습니다!"
            : isMuted
            ? "Audio is successfully muted!"
            : "Audio is successfully unmuted!";

    const msgFont = locale === "korean" ? "galmuri" : "gameboy";

    const msg = k.add([
        k.text(msgText, {
            size: 20,
            font: msgFont,
        }),
        k.pos(k.center().x, k.height() - 40),
        k.anchor("center"),
        k.fixed(),
        { tag: "audio-notice" },
    ]);

    k.wait(1.5, () => {
        k.destroy(msg);
        isLockedRef.value = false;
    });
}

export function setupMainMenuShortcut(k, gameState) {
    // ESC 키는 더 이상 반응하지 않음 (제거됨)
    // k.onKeyPress("escape", () => { ... }); // 제거됨

    // 수정된 부분: 1번 키를 눌렀을 때 확인 후 메인 메뉴로 돌아가기
    k.onKeyPress("1", async () => {
        playSfxWithDucking(k, "bubble-sfx", { estimatedDuration: 1.0 });

        const locale = gameState.getLocale();
        const font = locale === "korean" ? "galmuri" : "gameboy";

        // 확인 메시지 표시
        const confirmText =
            locale === "korean"
                ? "메인 메뉴로 돌아가시겠습니까?\n지금까지 했던 내용은 사라집니다.\n\n[Enter] 확인    [ESC] 취소"
                : "Return to main menu?\nAll progress will be lost.\n\n[Enter] Confirm    [ESC] Cancel";

        const confirmBox = k.add([
            k.rect(k.width() * 0.8, k.height() * 0.4),
            k.color(0, 0, 0),
            k.outline(2, k.Color.WHITE),
            k.pos(k.width() / 2, k.height() / 2),
            k.anchor("center"),
            k.fixed(),
            k.z(1000),
            "confirm-box",
        ]);

        const confirmMsg = k.add([
            k.text(confirmText, {
                size: 21,
                font: font,
                width: k.width() * 0.7,
                lineSpacing: 4,
                align: "center",
            }),
            k.pos(k.width() / 2, k.height() / 2),
            k.anchor("center"),
            k.fixed(),
            k.z(1001),
            "confirm-text",
        ]);

        // 확인/취소 입력 대기
        const enterHandler = k.onKeyPress("enter", () => {
            playSfxWithDucking(k, "confirm-beep-sfx", {
                estimatedDuration: 0.8,
            });

            // 확인 박스 제거
            k.destroyAll("confirm-box");
            k.destroyAll("confirm-text");

            // BGM 정지
            if (gameState.bgmHandle) {
                gameState.bgmHandle.stop();
            }

            // 추가된 부분: 모든 진행상황 초기화
            gameState.setHasEatenMushroom(false);
            gameState.setHasNewchaDialogShown(false);
            gameState.setIsPlayerTall(false);
            gameState.setIsGhostDefeated(false);
            gameState.setIsSonSaved(false);
            gameState.setTargetSpawn(null);
            gameState.clearInteractableObject();
            console.log("[DEBUG] ✅ 모든 진행상황이 초기화되었습니다.");

            // 메인 메뉴로 이동
            k.go("mainMenu");

            // 이벤트 핸들러 제거
            enterHandler.cancel();
            escapeHandler.cancel();
        });

        const escapeHandler = k.onKeyPress("escape", () => {
            playSfxWithDucking(k, "bubble-sfx", { estimatedDuration: 1.0 });

            // 확인 박스만 제거
            k.destroyAll("confirm-box");
            k.destroyAll("confirm-text");

            // 이벤트 핸들러 제거
            enterHandler.cancel();
            escapeHandler.cancel();
        });
    });

    // 수정된 부분: start 버튼을 눌렀을 때도 확인 후 메인 메뉴로 돌아가기
    k.onGamepadButtonPress("start", async () => {
        playSfxWithDucking(k, "bubble-sfx", { estimatedDuration: 1.0 });

        const locale = gameState.getLocale();
        const font = locale === "korean" ? "galmuri" : "gameboy";

        // 확인 메시지 표시
        const confirmText =
            locale === "korean"
                ? "메인 메뉴로 돌아가시겠습니까?\n지금까지 했던 내용은 사라집니다.\n\n[A] 확인    [B] 취소"
                : "Return to main menu?\nAll progress will be lost.\n\n[A] Confirm    [B] Cancel";

        const confirmBox = k.add([
            k.rect(k.width() * 0.8, k.height() * 0.4),
            k.color(0, 0, 0),
            k.outline(2, k.Color.WHITE),
            k.pos(k.width() / 2, k.height() / 2),
            k.anchor("center"),
            k.fixed(),
            k.z(1000),
            "confirm-box",
        ]);

        const confirmMsg = k.add([
            k.text(confirmText, {
                size: 21,
                font: font,
                width: k.width() * 0.7,
                lineSpacing: 4,
                align: "center",
            }),
            k.pos(k.width() / 2, k.height() / 2),
            k.anchor("center"),
            k.fixed(),
            k.z(1001),
            "confirm-text",
        ]);

        // 확인/취소 입력 대기
        const aHandler = k.onGamepadButtonPress("east", () => {
            playSfxWithDucking(k, "confirm-beep-sfx", {
                estimatedDuration: 0.8,
            });

            // 확인 박스 제거
            k.destroyAll("confirm-box");
            k.destroyAll("confirm-text");

            // BGM 정지
            if (gameState.bgmHandle) {
                gameState.bgmHandle.stop();
            }

            // 추가된 부분: 모든 진행상황 초기화
            gameState.setHasEatenMushroom(false);
            gameState.setHasNewchaDialogShown(false);
            gameState.setIsPlayerTall(false);
            gameState.setIsGhostDefeated(false);
            gameState.setIsSonSaved(false);
            gameState.setTargetSpawn(null);
            gameState.clearInteractableObject();
            console.log("[DEBUG] ✅ 모든 진행상황이 초기화되었습니다.");

            // 메인 메뉴로 이동
            k.go("title");

            // 이벤트 핸들러 제거
            aHandler.cancel();
            bHandler.cancel();
        });

        const bHandler = k.onGamepadButtonPress("south", () => {
            playSfxWithDucking(k, "bubble-sfx", { estimatedDuration: 1.0 });

            // 확인 박스만 제거
            k.destroyAll("confirm-box");
            k.destroyAll("confirm-text");

            // 이벤트 핸들러 제거
            aHandler.cancel();
            bHandler.cancel();
        });
    });
}

// 수정된 부분: 전역 A/B 버튼 처리 함수 추가
export function setupGlobalGamepadButtons(k, gameState, options = {}) {
    // A버튼(east) - 확인 기능
    k.onGamepadButtonPress("east", () => {
        if (options.onConfirm) {
            options.onConfirm();
        }
    });

    // B버튼(south) - 취소 기능
    k.onGamepadButtonPress("south", () => {
        if (options.onCancel) {
            options.onCancel();
        }
    });
}

<<<<<<< HEAD
// 추가된 부분: 퀘스트 말풍선 시스템
// 말풍선 감정 상태 상수 정의
export const SPEECH_BUBBLE_STATES = {
    QUEST: 0, // 퀘스트 있는 상태
    VERY_HAPPY: 1, // 매우 만족한 상태
    NEUTRAL: 2, // 그냥 그런 상태
    SAD: 3, // 슬픈상태
    ANGRY: 4, // 화남
    UPSET: 5, // 언짢음
    HAPPY: 6, // 만족한 상태
    EMPTY: 7, // 빈 말풍선
};

export function addQuestBubble(k, student, map) {
    const questBubble = map.add([
        k.sprite("quest-exclamation", {
            frame: SPEECH_BUBBLE_STATES.QUEST, // 수정된 부분: 상수 사용
        }),
        k.pos(student.pos.x - 8, student.pos.y - 12), // 수정된 부분: 위치 조정 (왼쪽으로 8픽셀, 아래로 8픽셀)
        k.anchor("center"),
        k.scale(1.0), // 수정된 부분: 크기 조정 0.8 → 1.0
        k.z(20),
        k.opacity(1.0),
        "quest-bubble",
        { studentId: student.studentType },
    ]);

    let time = 0;
    let bounceDirection = 1;
    let pulseScale = 1.0; // 수정된 부분: 기본 크기 조정
    const minScale = 0.9; // 수정된 부분: 최소 크기 조정
    const maxScale = 1.1; // 수정된 부분: 최대 크기 조정
    const bounceSpeed = 3.0; // 수정된 부분: 바운스 속도 증가
    const pulseSpeed = 0.015; // 수정된 부분: 펄스 속도 조정

    questBubble.onUpdate(() => {
        time += k.dt();

        // 바운스 애니메이션 (위아래로 움직임) - 수정된 부분: 폭을 10%로 줄임
        const bounceOffset = Math.sin(time * bounceSpeed) * 0.1;
        questBubble.pos.x = student.pos.x + 8; // 수정된 부분: 고정된 x 오프셋
        questBubble.pos.y = student.pos.y - 7 + bounceOffset; // 수정된 부분: 조정된 기본 위치

        // 펄스 애니메이션 (크기 변화)
        pulseScale += bounceDirection * pulseSpeed;
        if (pulseScale >= maxScale) {
            pulseScale = maxScale;
            bounceDirection = -1;
        } else if (pulseScale <= minScale) {
            pulseScale = minScale;
            bounceDirection = 1;
        }
        questBubble.scale = pulseScale;
    });

    // student 객체에 말풍선 참조 저장
    student.questBubble = questBubble;

    return questBubble;
}

// 추가된 부분: 다른 감정 상태 말풍선을 생성하는 헬퍼 함수 (나중에 사용할 수 있도록)
export function addEmotionBubble(k, student, map, emotionState) {
    const emotionBubble = map.add([
        k.sprite("quest-exclamation", {
            frame: emotionState,
        }),
        k.pos(student.pos.x - 8, student.pos.y - 12), // 수정된 부분: 위치 조정 (동일하게 적용)
        k.anchor("center"),
        k.scale(1.0),
        k.z(20),
        k.opacity(1.0),
        "emotion-bubble",
        { studentId: student.studentType },
    ]);

    let time = 0;
    let bounceDirection = 1;
    let pulseScale = 1.0;
    const minScale = 0.9;
    const maxScale = 1.1;
    const bounceSpeed = 3.0;
    const pulseSpeed = 0.015;

    emotionBubble.onUpdate(() => {
        time += k.dt();

        // 수정된 부분: 바운스 폭을 10%로 줄임
        const bounceOffset = Math.sin(time * bounceSpeed) * 0.2;
        emotionBubble.pos.x = student.pos.x - 8; // 수정된 부분: 고정된 x 오프셋
        emotionBubble.pos.y = student.pos.y - 12 + bounceOffset; // 수정된 부분: 조정된 기본 위치

        pulseScale += bounceDirection * pulseSpeed;
        if (pulseScale >= maxScale) {
            pulseScale = maxScale;
            bounceDirection = -1;
        } else if (pulseScale <= minScale) {
            pulseScale = minScale;
            bounceDirection = 1;
        }
        emotionBubble.scale = pulseScale;
    });

    student.emotionBubble = emotionBubble;

    return emotionBubble;
}

export function removeQuestBubble(k, student) {
    if (student.questBubble && student.questBubble.exists()) {
        student.questBubble.destroy();
        student.questBubble = null;
    }
}

export function updateQuestBubbles(k, students, map) {
    students.forEach((student) => {
        if (!student.exists()) return;

        const questData = gameState.getStudentQuest(student.studentType);
        const shouldShowBubble = questData.hasQuest && !questData.isCompleted;

        if (shouldShowBubble && !student.questBubble) {
            // 퀘스트가 있는데 말풍선이 없으면 생성
            addQuestBubble(k, student, map);
        } else if (!shouldShowBubble && student.questBubble) {
            // 퀘스트가 없는데 말풍선이 있으면 제거
            removeQuestBubble(k, student);
        }
    });
}

export function initializeQuestBubbles(k, students, map) {
    // 모든 학생에 대해 초기 퀘스트 말풍선 상태 설정
    updateQuestBubbles(k, students, map);
}

// 커스텀 애니메이션 함수들
export function fadeIn(k, gameObj, duration = 1000, delay = 0) {
    return new Promise((resolve) => {
        if (delay > 0) {
            setTimeout(() => startFadeIn(), delay);
        } else {
            startFadeIn();
        }

        function startFadeIn() {
            const startTime = performance.now();
            const startOpacity = gameObj.opacity || 0;
            const endOpacity = 1;

            gameObj.opacity = startOpacity;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // easeInOut 효과
                const easedProgress = progress * progress * (3 - 2 * progress);
                
                gameObj.opacity = startOpacity + (endOpacity - startOpacity) * easedProgress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gameObj.opacity = endOpacity;
                    resolve();
                }
            }

            requestAnimationFrame(animate);
        }
    });
}

export function fadeOut(k, gameObj, duration = 1000, delay = 0) {
    return new Promise((resolve) => {
        if (delay > 0) {
            setTimeout(() => startFadeOut(), delay);
        } else {
            startFadeOut();
        }

        function startFadeOut() {
            const startTime = performance.now();
            const startOpacity = gameObj.opacity || 1;
            const endOpacity = 0;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // easeInOut 효과
                const easedProgress = progress * progress * (3 - 2 * progress);
                
                gameObj.opacity = startOpacity + (endOpacity - startOpacity) * easedProgress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gameObj.opacity = endOpacity;
                    resolve();
                }
            }

            requestAnimationFrame(animate);
        }
    });
}

export function scaleIn(k, gameObj, duration = 1000, delay = 0, fromScale = 0.5, toScale = 1) {
    return new Promise((resolve) => {
        if (delay > 0) {
            setTimeout(() => startScaleIn(), delay);
        } else {
            startScaleIn();
        }

        function startScaleIn() {
            const startTime = performance.now();
            gameObj.scale = fromScale;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // bounce 효과
                const bounceProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                gameObj.scale = fromScale + (toScale - fromScale) * bounceProgress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gameObj.scale = toScale;
                    resolve();
                }
            }

            requestAnimationFrame(animate);
        }
    });
}

export function blink(k, gameObj, duration = 1000, blinkCount = 3) {
    return new Promise((resolve) => {
        const blinkDuration = duration / (blinkCount * 2);
        let currentBlink = 0;

        function doBlink() {
            if (currentBlink >= blinkCount) {
                gameObj.opacity = 1;
                resolve();
                return;
            }

            // fade out
            fadeOut(k, gameObj, blinkDuration).then(() => {
                // fade in
                fadeIn(k, gameObj, blinkDuration).then(() => {
                    currentBlink++;
                    doBlink();
                });
            });
        }

        doBlink();
    });
}

export function pulse(k, gameObj, duration = 2000, minOpacity = 0.7, maxOpacity = 1) {
    const startTime = performance.now();
    
    function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = (elapsed % duration) / duration;
        
        // 사인파를 이용한 부드러운 펄스 효과
        const opacity = minOpacity + (maxOpacity - minOpacity) * (Math.sin(progress * Math.PI * 2) * 0.5 + 0.5);
        gameObj.opacity = opacity;
        
        requestAnimationFrame(animate);
    }
    
    requestAnimationFrame(animate);
}

export function slideIn(k, gameObj, direction = 'bottom', duration = 1000, delay = 0, distance = 100) {
    return new Promise((resolve) => {
        if (delay > 0) {
            setTimeout(() => startSlideIn(), delay);
        } else {
            startSlideIn();
        }

        function startSlideIn() {
            const startTime = performance.now();
            const originalPos = { x: gameObj.pos.x, y: gameObj.pos.y };
            
            // 시작 위치 설정
            switch(direction) {
                case 'bottom':
                    gameObj.pos.y += distance;
                    break;
                case 'top':
                    gameObj.pos.y -= distance;
                    break;
                case 'left':
                    gameObj.pos.x -= distance;
                    break;
                case 'right':
                    gameObj.pos.x += distance;
                    break;
            }

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // easeOutBack 효과 (약간 튀는 느낌)
                const c1 = 1.70158;
                const c3 = c1 + 1;
                const easedProgress = 1 + c3 * Math.pow(progress - 1, 3) + c1 * Math.pow(progress - 1, 2);
                
                // 위치 보간
                switch(direction) {
                    case 'bottom':
                        gameObj.pos.y = originalPos.y + distance * (1 - easedProgress);
                        break;
                    case 'top':
                        gameObj.pos.y = originalPos.y - distance * (1 - easedProgress);
                        break;
                    case 'left':
                        gameObj.pos.x = originalPos.x - distance * (1 - easedProgress);
                        break;
                    case 'right':
                        gameObj.pos.x = originalPos.x + distance * (1 - easedProgress);
                        break;
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gameObj.pos.x = originalPos.x;
                    gameObj.pos.y = originalPos.y;
                    resolve();
                }
            }

            requestAnimationFrame(animate);
        }
    });
}
=======
// 퀘스트 시스템 관련 함수들은 새로운 구조로 리팩토링되었습니다.
// 호환성을 위해 재export 합니다.
export { 
    SPEECH_BUBBLE_STATES,
    addQuestBubble,
    addEmotionBubble,
    removeQuestBubble,
    updateQuestBubbles,
    initializeQuestBubbles 
} from "./systems/questUI.js";
>>>>>>> 168311de5f598678acb6febbe3dee27fd4ff40bf
